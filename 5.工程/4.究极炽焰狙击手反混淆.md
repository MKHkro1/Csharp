```C#
using System;
using System.Collections;
using System.Runtime.CompilerServices;
using BepInEx;
using BepInEx.Core.Logging.Interpolation;
using BepInEx.Logging;
using BepInEx.Unity.IL2CPP;
using HarmonyLib;
using Il2CppInterop.Runtime.InteropTypes;
using Il2CppInterop.Runtime.InteropTypes.Arrays;
using Il2CppSystem;
using Il2CppSystem.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.Rendering;

namespace UltimateBlazingFireSniper
{
    /// <summary>
    /// 终极烈焰狙击手 - BepInEx插件主类
    /// 这是一个为游戏添加自定义植物的MOD
    /// </summary>
    [BepInPlugin("UltimateBlazingFireSniper", "UltimateBlazingFireSniper", "1.0.0")]
    public class Plugin : BasePlugin
    {
        // 静态变量定义
        internal static ManualLogSource Logger;                    // BepInEx日志记录器
        public static AssetBundle AssetBundle;                    // 资源包，包含自定义植物的模型、贴图等
        public static PlantType NewPlantType;                     // 新植物的类型枚举
        public static BulletType NewBulletType;                   // 新植物使用的子弹类型

        /// <summary>
        /// BepInEx插件加载入口点
        /// 当游戏启动时，这个方法会被自动调用
        /// </summary>
        public override void Load()
        {
            // 初始化日志记录器
            Logger = Log;
            
            // 记录插件开始加载的日志信息
            var handler = new BepInExInfoLogInterpolatedStringHandler(0, 1);
            handler.AppendLiteral("正在加载终极烈焰狙击手插件...");
            Logger.LogInfo(handler);
            
            // 使用Harmony进行代码修补（Hook游戏原有方法）
            var harmony = new Harmony("UltimateBlazingFireSniper");
            harmony.PatchAll();  // 自动查找并应用所有带有[HarmonyPatch]特性的类
            
            // 加载自定义植物的资源
            LoadUltimateBlazingFireSniper();
            
            Logger.LogInfo("终极烈焰狙击手插件加载完成！");
        }

        /// <summary>
        /// 从Base64字符串加载资源包
        /// 这种方法可以避免直接暴露资源文件
        /// </summary>
        /// <param name="base64String">Base64编码的资源包数据</param>
        /// <param name="path">资源路径（可选）</param>
        /// <returns>加载的资源包对象</returns>
        public static AssetBundle LoadAssetBundle(string base64String, string path = "")
        {
            try
            {
                // 将Base64字符串转换为字节数组
                byte[] data = Convert.FromBase64String(base64String);
                // 从内存加载资源包
                AssetBundle bundle = AssetBundle.LoadFromMemory(data);
                return bundle;
            }
            catch (Exception ex)
            {
                Logger.LogError($"加载资源包失败: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// 加载终极烈焰狙击手的所有资源并初始化
        /// 这是MOD的核心初始化方法
        /// </summary>
        public static void LoadUltimateBlazingFireSniper()
        {
            try
            {
                // 加载资源包（实际的Base64字符串会在其他地方提供）
                // 这里使用伪代码，实际实现需要提供真实的Base64数据
                AssetBundle = LoadAssetBundle("/* 这里应该是Base64编码的资源包数据 */");
                
                if (AssetBundle != null)
                {
                    // 加载资源包中的所有资源
                    var allAssets = AssetBundle.LoadAllAssets();
                    
                    // 注册新植物类型到游戏系统中
                    RegisterNewPlant();
                    // 注册新子弹类型
                    RegisterNewBullet();
                    // 更新植物数据配置
                    UpdatePlantData();
                    
                    Logger.LogInfo("终极烈焰狙击手资源加载成功！");
                }
                else
                {
                    Logger.LogError("资源包加载失败，终极烈焰狙击手无法正常使用！");
                }
            }
            catch (Exception ex)
            {
                Logger.LogError($"加载终极烈焰狙击手时发生错误: {ex.Message}");
            }
        }

        /// <summary>
        /// 向游戏注册新植物类型
        /// 这个方法会将自定义植物添加到游戏的植物列表中
        /// </summary>
        private static void RegisterNewPlant()
        {
            // 这里会调用游戏内部的API来注册新植物
            // 具体实现取决于目标游戏的结构
            // 可能包括：设置植物名称、消耗阳光、冷却时间、攻击力等属性
            
            Logger.LogInfo("正在注册新植物类型...");
        }

        /// <summary>
        /// 注册新子弹类型
        /// 为自定义植物创建专用的子弹类型
        /// </summary>
        private static void RegisterNewBullet()
        {
            // 创建特殊的子弹类型，可能带有火焰、穿透等特效
            Logger.LogInfo("正在注册新子弹类型...");
        }

        /// <summary>
        /// 更新植物数据加载器
        /// 确保游戏能够正确识别和加载我们的自定义植物
        /// </summary>
        private static void UpdatePlantData()
        {
            // 修改游戏的植物数据系统，添加对新植物的支持
            // 这可能涉及到修改数据表、配置文件等
            
            Logger.LogInfo("正在更新植物数据系统...");
        }
    }

    /// <summary>
    /// 终极烈焰狙击手植物行为控制器
    /// 这个MonoBehaviour组件会被附加到自定义植物游戏对象上
    /// 负责控制植物的所有特殊行为和效果
    /// </summary>
    public class UltimateBlazingFireSniper : MonoBehaviour
    {
        // 私有字段
        private Plant plant;                      // 对基础植物组件的引用
        private int attackCounter;                // 攻击计数器，用于特殊攻击计数
        private int specialAbilityCounter;        // 特殊能力计数器
        public int CollectSunDmg;                 // 收集阳光伤害值（这个值既影响伤害也影响阳光收集）
        private float attackTimer;                // 攻击计时器，控制攻击频率
        private TextMeshPro statusText;           // 状态显示文本（在植物上方显示）

        /// <summary>
        /// 植物组件属性（懒加载）
        /// 确保能够获取到植物基础组件
        /// </summary>
        private Plant PlantComponent 
        { 
            get 
            { 
                // 如果plant为空，则从当前游戏对象获取Plant组件
                if (plant == null) 
                    plant = GetComponent<Plant>();
                return plant;
            } 
        }

        /// <summary>
        /// Unity Start方法 - 在游戏对象初始化时调用
        /// 用于初始化自定义植物的状态显示
        /// </summary>
        private void Start()
        {
            // 检查植物是否有文本头部（用于显示状态信息）
            if (PlantComponent.textHead != null)
            {
                // 创建状态文本显示对象
                // 复制游戏中现有的健康文本对象作为模板
                GameObject textObject = Instantiate(
                    PlantComponent.transform.Find("textHead/HealthIcon(Clone)/text/HealthText").gameObject, 
                    PlantComponent.textHead.transform);
                
                // 调整文本位置，使其在植物上方显示
                Vector2 textPosition = PlantComponent.textHead.transform.position;
                textPosition.y -= 0.5f;  // 向下偏移0.5个单位
                textObject.transform.position = textPosition;
                textObject.SetActive(true);  // 激活文本对象
                
                // 获取文本组件
                statusText = textObject.GetComponent<TextMeshPro>();
                statusText.fontSize = 10f;  // 设置合适的字体大小
                
                // 添加排序组组件，确保文本正确渲染在合适层级
                SortingGroup sortingGroup = textObject.AddComponent<SortingGroup>();
                sortingGroup.sortAtRoot = true;  // 在根层级排序
                // 设置排序图层名称，确保在不同行显示正确
                sortingGroup.sortingLayerName = $"zombie{PlantComponent.thePlantRow + 1}";
                
                // 设置初始文本内容为伤害值
                statusText.text = CollectSunDmg.ToString();
                // 设置文本颜色为青色，便于区分
                statusText.color = new Color(0f, 1f, 1f, 1f);
            }
        }

        /// <summary>
        /// Unity Update方法 - 每帧调用
        /// 处理植物的攻击逻辑和状态更新
        /// </summary>
        private void Update()
        {
            // 更新攻击计时器
            attackTimer -= Time.deltaTime;
            
            // 检查是否到达攻击时间且游戏处于可攻击状态
            if (attackTimer < 0f && GameAPP.theGameStatus == null)
            {
                // 执行攻击逻辑
                PerformAttack();
                // 重置攻击计时器（2秒攻击间隔）
                attackTimer = 2f;
                
                // 更新状态显示文本
                if (statusText != null)
                {
                    statusText.text = CollectSunDmg.ToString();
                }
            }
        }

        /// <summary>
        /// 执行攻击逻辑
        /// 这是植物的核心攻击方法
        /// </summary>
        private void PerformAttack()
        {
            // 这里实现植物的具体攻击逻辑：
            // 1. 搜索范围内的僵尸
            // 2. 创建子弹或直接造成伤害
            // 3. 播放攻击动画和音效
            // 4. 处理特殊效果（如火焰伤害、穿透等）
            
            // 伪代码示例：
            // var targetZombie = FindNearestZombie();
            // if (targetZombie != null) 
            // {
            //     CreateBullet(targetZombie);
            //     PlayAttackAnimation();
            // }
            
            attackCounter++;  // 增加攻击计数，可能用于触发特殊能力
        }

        /// <summary>
        /// 切换植物模型
        /// 根据植物状态或升级改变外观
        /// </summary>
        public void ChangeModel()
        {
            // 实现模型切换逻辑：
            // 1. 根据植物等级切换不同模型
            // 2. 根据特殊状态（如强化、受伤）改变外观
            // 3. 播放模型切换动画
            
            Logger.LogInfo("切换终极烈焰狙击手模型");
        }

        /// <summary>
        /// 获取植物当前状态
        /// 用于UI显示或其他系统查询植物状态
        /// </summary>
        /// <returns>当前状态值（这里返回伤害值作为状态指示）</returns>
        public int GetStatus()
        {
            return CollectSunDmg;
        }
    }

    // =========================================================================
    // Harmony补丁类 - 用于修改游戏原有行为
    // 这些类使用Harmony库来Hook游戏方法，实现自定义功能
    // =========================================================================

    /// <summary>
    /// 游戏启动补丁
    /// 在游戏初始化时确保我们的自定义植物被加载
    /// </summary>
    [HarmonyPatch(typeof(GameAPP), "Awake")]
    public class GameAPPAwakePatch
    {
        /// <summary>
        /// 后置补丁 - 在GameAPP.Awake方法执行后运行
        /// </summary>
        [HarmonyPostfix]
        public static void Postfix()
        {
            // 确保游戏启动时加载我们的自定义植物
            Plugin.LoadUltimateBlazingFireSniper();
        }
    }

    /// <summary>
    /// 宝藏数据补丁
    /// 修改卡片等级系统以支持自定义植物
    /// </summary>
    [HarmonyPatch(typeof(TreasureData), "GetCardLevel")]
    public class TreasureDataGetCardLevelPatch
    {
        /// <summary>
        /// 后置补丁 - 修改获取卡片等级的结果
        /// </summary>
        /// <param name="thePlantType">植物类型</param>
        /// <param name="__result">原始方法返回的卡片等级</param>
        [HarmonyPostfix]
        public static void Postfix(ref PlantType thePlantType, ref CardLevel __result)
        {
            // 如果查询的是我们的自定义植物，修改其卡片等级
            if (thePlantType == Plugin.NewPlantType)
            {
                // 这里可以设置自定义的卡片等级逻辑
                // 例如：根据MOD配置返回特定等级
            }
        }
    }

    /// <summary>
    /// 阳光硬币补丁
    /// 修改阳光收集行为，当自定义植物存在时可能有特殊效果
    /// </summary>
    [HarmonyPatch(typeof(CoinSun), "Start")]
    public class CoinSunStartPatch
    {
        /// <summary>
        /// 后置补丁 - 在阳光硬币初始化后执行
        /// </summary>
        /// <param name="__instance">阳光硬币实例</param>
        [HarmonyPostfix]
        public static void Postfix(CoinSun __instance)
        {
            // 当场上存在终极烈焰狙击手时，可能修改阳光行为：
            // 1. 增加阳光价值
            // 2. 添加特殊视觉效果
            // 3. 触发植物特殊能力
        }
    }

    /// <summary>
    /// 狙击豌豆搜索补丁
    /// 修改僵尸搜索逻辑，实现自定义的 targeting 行为
    /// </summary>
    [HarmonyPatch(typeof(SniperPea), "SearchZombie")]
    public class SniperPeaPSearchZombiePatch
    {
        /// <summary>
        /// 前置补丁 - 在原始搜索方法执行前运行
        /// </summary>
        /// <param name="__instance">狙击豌豆实例</param>
        /// <returns>是否继续执行原始方法</returns>
        [HarmonyPrefix]
        public static bool Prefix(SniperPea __instance)
        {
            // 这里可以实现自定义的僵尸搜索逻辑：
            // 1. 优先攻击特定类型僵尸
            // 2. 修改搜索范围
            // 3. 添加特殊目标选择条件
            
            return true; // 返回true表示继续执行原始方法
        }
    }

    /// <summary>
    /// 火焰狙击手攻击补丁
    /// 修改攻击行为，添加火焰特效和额外伤害
    /// </summary>
    [HarmonyPatch(typeof(FireSniper), "AttackZombie")]
    public class FireSniperPatch
    {
        /// <summary>
        /// 前置补丁 - 修改攻击参数
        /// </summary>
        /// <param name="__instance">火焰狙击手实例</param>
        /// <param name="zombie">目标僵尸</param>
        /// <param name="damage">伤害值（引用参数，可修改）</param>
        /// <returns>是否继续执行原始方法</returns>
        [HarmonyPrefix]
        public static bool Prefix(FireSniper __instance, ref Zombie zombie, ref int damage)
        {
            // 修改攻击逻辑：
            // 1. 增加火焰伤害
            // 2. 添加点燃效果
            // 3. 修改伤害类型
            
            // 例如：如果是我们的自定义植物，增加额外伤害
            // if (__instance.GetPlantType() == Plugin.NewPlantType) 
            // {
            //     damage += 10; // 增加10点额外伤害
            // }
            
            return true; // 继续执行原始方法
        }
    }

    /// <summary>
    /// 金钱强化补丁
    /// 修改植物强化系统，支持自定义植物的强化效果
    /// </summary>
    [HarmonyPatch(typeof(Money), "ReinforcePlant")]
    public class MoneyReinforcePlantPatch
    {
        /// <summary>
        /// 前置补丁 - 在强化植物前执行
        /// </summary>
        /// <param name="__instance">金钱系统实例</param>
        /// <param name="plant">要强化的植物</param>
        /// <returns>是否继续执行原始方法</returns>
        [HarmonyPrefix]
        public static bool Prefix(Money __instance, ref Plant plant)
        {
            // 如果是我们的自定义植物，应用特殊强化效果：
            // 1. 增加伤害
            // 2. 减少攻击间隔
            // 3. 添加新能力
            
            return true; // 继续执行原始方法
        }
    }

    /// <summary>
    /// 植物图鉴补丁
    /// 将自定义植物添加到游戏的图鉴系统中
    /// </summary>
    [HarmonyPatch(typeof(AlmanacPlantBank), "InitNameAndInfoFromJson")]
    public class AlmanacMgrInitNameAndInfoFromJsonPatch
    {
        /// <summary>
        /// 后置补丁 - 在图鉴初始化后添加自定义植物
        /// </summary>
        /// <param name="__instance">植物图鉴实例</param>
        [HarmonyPostfix]
        public static void Postfix(AlmanacPlantBank __instance)
        {
            // 将终极烈焰狙击手添加到植物图鉴中：
            // 1. 添加植物名称和描述
            // 2. 设置正确的属性显示
            // 3. 加载自定义图标和图片
            
            Plugin.Logger.LogInfo("已将终极烈焰狙击手添加到植物图鉴");
        }
    }
}
```